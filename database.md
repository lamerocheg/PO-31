# Базы данных

-----

## Назначение СУБД(Систем управления базами данных)

Основная идея это хранение на внешнем носителе не только самих данных , но и описание их структур.

![alt text](http://i.imgur.com/lnG78pB.png "классическое взаимодействие с файлами")

![alt text](http://i.imgur.com/TkRCf0J.png "взаимодействие программ с файлами при помощи субд")

#### достоинства использования СУБД :

1. снижение сетевого трафика.
2. возможность создания программ независимых от структуры хранения данных на внешнем устройстве.
3. возможность использования стандартных качественно реализованных СУБД алгоритмов обработки данных(сортировка, поиск, ведение индексов и т. д.)
4. автоматическое поддержание целостности данных. Авто резервное копирование, откат транзакций и др.
5. разграничение доступа к данным за счет авторизации пользователя и установки уровня по умолчанию
6. автоматизация отображения данных

---

## Иерархическая и сетевая модель данных

СУБД различаются способом представления связей между объектами(моделями данных) 

1. иерархическая
2. сетевая
3. реляционная
4. пост-реляционная
 
Исторически первой была система IMS  производства IBM  ее украли и назвали OKA. В ней 1 объект является главным а остальные подчиненные на разных уровнях иерархии.
недостаток : реальные объекты не всегда находятся в строгой иерархической зависимости. 
В сетевых базах любой объект может быть как главным так и подчиненным ADABAS ее украли и назвали ADABAC. Основной недостаток -  это инструмент для программистов.
В начале 70-х Кодд предложил реляционную модель СУБД.

-

## Реляционная модель СУБД.

Кодд стремился упростить структуру базы.
В традиционных реляционных СУБД данные хранятся в таблицах. Таблица соответствует типу объекта. Строка таблицы это экземпляр объекта. Столбец — значения атрибута в экземплярах. Имена таблиц уникальны в базе. Имена столбцов уникальны в таблице. Таблица может иметь произвольное количество строк. Возможно — ни одной. Строки таблицы не упорядочены. Нет понятия 1 строка или последняя. Каждая таблица содержит поле или совокупность полей однозначно определяющих запись это поле или совокупность называется первичный ключ. Поле или совокупность полей значение которых совпадают со значением первичного ключа одной из записей в другой таблице называются внешним ключом совокупность внешнего и первичного ключа определяют связь между объектами таблица с первичным ключом родительская , таблица с внешним ключом дочерняя. 

-

## Проектирование баз данных

#### этапы :

1. определение состава объектов
2. определение связи между объектами 
3. определение атибутов объектов 
4. нормализация отношений 

Предположим что база данных об учебном процессе. объекты будут `факультет` , `кафедра` , `преподаватель` , `группа` , `студент`

есть три типа связи. 
1. 1 к 1 :одному экземпляру первого типа соответствует 1 экземпляр второго типа (<--->). хотя такое возможно но встречается редко и вообще быть не должно. есть 2 причины почему одну таблицу можно разделить : производительность и упрощение администрирования. 
2. 1 к многим : 1 экземпляру объекта первого типа соответствует много экземплярова объектов второго типа (<--->->) .
3. многие ко многим : одному обекту первого тип могут соответствовать многие и наоборот. такх связей не существует . если реально такая связ есть то проблема решается добавленем еще одного типа объекта. дочернего по отношению к ним.

####Определение состава атрибутов объекта

1. поля первичного ключа
2. поля внешних ключей в дочерних таблицах
3. не ключевые атрибуты

####Нормализация отношений 

нормализация отношений это процесс выбора оптимального состава объектов. 

Пусть сведения о нагрузке представлены в таблице нагрузка преподавателя

####1НФ

Говорят что отношения находятся в первой нормальной форме если значения каждого атрибута неделимо.

Недостатки :
1. проблема реализации обновления данных(нельзя добавить преподавателя не имеющего нагрузки)
2. при удалении нагрузки теряются сведения о преподавателе
3. изменения значения атрибутов требуют просмотра всей таблицы 

####2НФ

отношения в первой нормальной форме и каждый неключевой атрибут полностью зависит от всех атрибутов первичного ключа

переход к 2НФ разделением отношения на несколько

есть недостатки :

1. нельзя добавить кафедру не указав преподавателя
2. при удалении преподавателей теряются ведения о кафедрах
3. изменение зависимости кафедра-факультет требует просмотра всего отношения 

####3НФ

Говорят что отношения в третьей нормалной форме если она во второй и каждый неключевой атрибут нетранзитивно зависит от ключа

преобразование путем разделения отношений 

достоинством нормализации является устранение избыточности данных. 

### дополниельные рекомедации по проектированию :

1. не нужно включать в базу атрибут значение которого может быть расчитано по другим атрибутам. т.к. тогда значние нового атрибута придется пересчитывать при изменении исходных данных. <триггер>
2. при наличии повторяющегося значения атрибута в таблице обычно выгодно создать дополнительную таблиу-справочник в формате код-значение. значение атрибут может мняться во времени и код решает проблему. при наличии справочника в приожениях можно выполнять не ввод значения а выбор из списка.

-

## Создание базы данных

теперь надо создать реальную базу данных. описать атблицы поля и связи. изначально в MS Acces. В любой СУБД есть визуальные средства для определения визуальной структуры базы данных. когда созаем пустую базу данных. потом можем создавать таблицы появляется форма где можно вводить имена полей и указывать их типы. 
#### Типы данных(полей)
######MS Access
* текстовое поле(250 символов/ можно указать длину)
* Memo(текстовое поле но длина до 2гб)
* числовой(в свойствах тип числа . целый - 2 байта , длинный целый 4 байта , плавающие 5 и 8 байт)
* денежный тип
* счетчик(длинное целое, значение которого автоматчески вырабатывается для каждой новой записи)
* логический
* дата\время
* #m/d/y# константа даты

######MS SQL Server
* char, varchar(эквиваленты ткстового поля до 8192 символов)
* text(устаревает) , varchar(max) 
* nchar , nvarchar , ntext - кодировка юникод
* tinyint целое 1 байт
* smallint 2 байта
* int 4 байта
* bigint 8 байтовое целое 
* money
* int + identity
* bit
* datetime

для поля счетчика должно быть индексировано и совпадения недопускаютяы
#### создание схемы данных

схемы данных испольуются при визуальном создании запросов . с помощью схемы данных указываются правила поддержания ссылочной целосности
меню - съема данных. 
правая кнопка на связи -> ссылочная целосность. в дочерню таблицу нельзя добавить запись с неверным кодом объекта раддомтельвой и нельзя удалить объект родительской если к нему привязаны объекты дочерней

##правило Кодда 

* правило информации : вся информация в базе данных представлена в виде таблиц
* правило гарантированного доступа : доступ к любому значению обеспечивается путем использования комбинации имени таблицы , значения первичного ключа и имени столбца 
* правило поддержки недействительных значений : должны поддерживаться `NULL` значения которые отличаются от пустой строки, строки пробелов, нуля и означают отстутствие значения 
* правило каталога основанного на реляционной модели : описание структуры базы данных тоже хранится в таблице 
* правило исчерпывающего подъязыка дат : должен существовать язык общения с СУБД операторы которого представимы в виде строки символов в соответсви с не которым синтаксисом. язык обеспечивает пределение структуры данных определение представлений которые являются виртуальными таблицами и позволяют показывать различным пользвателям различные фрагменты баз данных. поддерживать обработку данных. определение условий целосности данных. идентификацию прав доступа. границы транзакций.
* правило обновления представлений : все представления которые теоретически можно обновить должны быть дступны для обовления
* правило добавления обновления и удаления : возможность работы с таблицей как с единым целым должно быть не только при просмотре , но и при добавлении обновлении и удалении записи
* правило независимости физических данных : программы должны остаться нетронутыми при любых изменеиях физических способов хранения данных и методов работы с ними 
* правило независимости логических данных : прикладные программы должны отставаться нетронутыми при внесении в таблицы любых именения которые позваляют сохранить нетронутыми ранее содержащиеся в таблицах данные
* правило независимости условий целосности : дожна уществовать воможность определить условие целоности пеифические для конкретной базы даных а не хранть их в базе данных а не в прикладной программе 
* правило независимости распространения : реляционная СУБД не должна завсеть от птребностей конкртного клиента 
* првио единственности : если в реляционой системе есь низкоуровневый язык то не должно быть возмоостей оботи с помощиью этого языка учловия целосности данных

## операции реляционой алгебры 
операции реляционной алгебры это операции над таблицами результатом которых тоже являются таблицы . есть 5 основных и 4 вспомогательных. 
основные : 
* объединение 
* разность 
* проекция 
* выбор 
* декартово произведение . 
вспомогательные :
* пересечение 
* соединение 
* слияние
* деление
 вспомогательные выражаются через основные и служат для краткости записи.

# таблицы

#### объединение

`T = R U S` записи которые вхдят хотябы в одну из таблиц 

`ST = SM U STP` местные и те кто со стипендией 

#### разность

`T = R - S` записи которые входят в R но не входят в S

#### проекция

`T = R | Y``  несовпадающие строки из столбцов Y

`GR = (SM U SI) | {ГРП}` список групп

`GS = STP | {ГРП}` список групп где хотя бы один имеет стипендию

`GR - GS` группы где никто не получает стипендию 
 
 `STP|{ГРП} - (((SM U SI) - STP)|{ГРП}` групы в которых хотя-бы один не получает стипендию
 
#### операция выбора
 
 `T = R : L` подмножество строк R удовлетворяющее L
 
 `ДВ = (ОС ж ОЦН < 4) | {КСТО}` коды двоечников
 
#### декартово произведение
 
 `T = R * S` пусть  R и S  содержат k1 k2 столбцов и n1 n2 строк. декартово произведение это таблица из k1 + k2 столбцов включающее в себя все сочетация строк из R и S (n1 * n2) 
 
 `(SM U SI) * ДВ` 
 
 `таблица`
 
 `(((SM u SI) * ДВ) : КСТ = КСТО) | {ФИО , ГРП}`
 
###### дополнительные операции выражаюются из базовых
 
 
## Выборка из одной таблицы

примеры на трех таблицах : преподаватель студент и оценка


# таблицы 


##### преподаватель

| pnum | pname | pcaf|
|------|-------|-----|
|  1   |  П-1  | К-1 |
|  2   |  П-2  | К-2 |
|  3   |  П-3  | К-3 |


##### студент 

| snum | pname | sgrp| spdp |
|------|-------|-----|------|
|   1  |  С-1  | Г-1 |   1  |
|   2  |  С-2  | Г-2 |   1  |
|   3  |  С-3  | Г-2 |   2  |
|   4  |  С-4  | Г-3 | NULL |

##### оценка 

| onum | opnum | osnum | odate | ocen |
|------|-------|-------|-------|------|
|   1  |   1   |   1   | 10/01 |  10  |
|   2  |   1   |   2   | 11/01 |   8  |
|   3  |   1   |   3   | 10/01 |   6  |
|   4  |   3   |   1   | 15/01 |  10  |
|   5  |   3   |   3   | 16/01 |   2  |
|   6  |   3   |   3   | 20/01 |   4  |

#### общий формат
```SQL
SELECT список_полей
 FROM список_таблиц
 [WHERE условие]
 [GROUP BY поле_группировки]
 [HAVING условие]
 [ORDER BY поле_сортировки]
```

в качестве списка полей можно указать `*` т.е. все поля 

```SQL
 SELECT * FROM  ПРЕПОД
```
можно перечислять поля через запятую

```SQL
 SELECT Sgrp , Sname FROM  СТУДЕНТ
```
если перед списком полей указать `DESTINCT` то удаляются повторяющиеся записи

```SQL
 SELECT DISTINCT Sgrp FROM  СТУДЕНТ
```
для поля можно задать новое имя `[as] новое_имя` 

```SQL
 SELECT Pname as ФИО , Pcaf as Кафедра FROM  ПРЕП
```
вместо имени поля можно указать выражение

```SQL
 SELECT OSnum , Odate , ocen , 10 - ocen as Недобор FROM ОЦЕНКА
```
#### WHERE 
в предложении WHERE задается условие отбора записей
* операторы` < > <= >= = <> !=`
* логические операторы `AND , OR , NOT`
* специальные операторы 

преподаватели кафедры К-1 :
```SQL
 SELECT Pname from ПРЕПОД where pcaf = `K-1`
```
студенты групп Г-1  и Г-2:
```SQL
 SELECT * from  СТУДЕНТ Sgrp = `Г-1` OR Sgrp = `Г-2`
```

положительные оценки студентов полученные с 15 по 20 января:
```SQL
 SELECT * from  ОЦЕНКА where ocen >= 4 and Odate >= `15/01` and Odate <= `20/01`
```
поожительные оценки студентов с кодами 1 и 2
```SQL
 SELECT * from  ОЦЕНКА where ocen >= 4  and ( osnum = 1 or osnum = 2)
```
#### специальные операторы 
`IN , BETWEEN , LIKE , IS NULL`

* IN `поле IN (знач1 , знач 2)`

преподаватели кафедры К-1 И К-2
```SQL
 SELECT Pname , Pcaf FROM  ПРЕП  where pcaf IN(`K-1` , `K-2`)
```
все студенты кроме студентов из групп Г-1 Г-2: 

```SQL
 SELECT * FROM  СТУДЕНТ where not sgrp in (`Г-1` , `Г-2`)
```

* Between `поле Between знач1 and знач2` находится в диапазоне включая границы 

получить оценки от 6 до 8 полученные с 10 до 15
```SQL
 SELECT  * from ОЕНКА where ocen between 6 and 8 and odate between '10/01' and '15/01' 
```

* Like `поле LIKE шаблон`

 используется только в символьных полях

* IS NULL  

при сравнении значений null с не null  не true / false , а  unknown == false

студенты без руководителя дипломной:
```SQL
 SELECT * from СТУДЕНТ spdp is null
```

студенты с руководителем дипломной:
```SQL
 SELECT * from СТУДЕНТ spdp is not null
```
## объеденение нескольких таблиц

получить фамилии дипломников с указанием фамилии руководителя
```SQL
 SELECT * FROM СТУДЕНТ , ПРЕП
```

получить оценки студентов из гуппы г-2 с указанием фамилии преподавателя и даты
```SQL
 SELECT pname , sname , odate , ocen 
 FROM  ПРЕП , СТУД , ОЦЕНКА 
 WHERE osnum = snum and opnum = pnum and sgrp = 'г-2'
```
фамилии руководителей дипломой в группах г-1 и г-2
```SQL
 select distinct pname
 from ПРЕП, СТУД
 where spdp = pnum and (sgrp = 'г-1' or sgrp = 'г-2')
```
если будут поля назван одинаково то имя полей нужно уточнять ИМЯ_ТАБЛИЦЫ.название поля

для таблицы можно дать новое имя. `from таблица [as] новое_имя`

получить все пары фамилий студентов обучающихся в одной и той же группе
```SQL
select с1.sname as ФИО1,  с2.sname as ФИО2 from студент с1 , студент с2 where с1.sgrp = с2.sgrp and с1.snum <> с2.snum
```
для объеденения таблиц можно использовать оператор `join` в предложении `from` 
```SQL
табл1 {INNER | LEFT | RIGHT} JOIN табл2 ON условие
```
фамилии дипломников с указаие руководителя
```SQL
 SELECT sname , pname
 from СТУДЕНТ INNNER JOIN преп on spdp=pnum

```
```SQL
 SELECT sname , pname , odate , ocen
 from (ПРЕП inner JOIN оценка on pnum=opnum) inner JOIN СТУДЕНТ on osnum = snum 
```
#### left JOIN
создаетс левое внешнее объединение все записи первой таблицы входят в результат даже если нет соответствующей записи во второй таблице. для эих записей в полях второй таблицы стоит null

получить фамилии всех студетов , для дипломников укаать фамилию руководителя
```SQL
 SELECT sname , pnae
 FROM СТУД LEFT JOIN ПРЕП оn spdp = pnum 
```

#### right JOIN 
тоже самое что и left , но все записи второй таблицы включаются в результат

вывесьи фамилии студентов которые не сдавали экзамены
```SQL
 SELECT sname FROM СТУДЕНТ LEFT JOIN ОЦЕНКА  ON SNUM = OSNUM
```
 
## Сортировка результатов запроса
`ORDER BY поле1 [asc / desc] [, поле2 [asc/desc]]` 
получиь сведения об оценках оотсортированные по коду студента и убыванию оценки 

```SQL
 SELECT * FROM ОЦЕНКА osNum , ocen desc
```

вместо имени поля можно указать его номер 

```SQL
SELECT sname ,  sgrp  FROM СТУДЕНТ ORDER BY sgrp , 1 
```

## Функции агрегирования 
 * COUNT 
 * MIN
 * MAX
 * SUM числовой
 * AVG числовой

имена полей - параметры функции
`select count(*) as cs from СТУДЕНТ` возвращает колличество записей
`COUNT(ПОЛЕ)`  - колличество не null значений поля
`select count(spdp) as cs from СТУДЕНТ` колличество дипломников


#### GROUP BY

GROUP BY поле1 [, поле 2]

пример: получить коды руководителей дипломов с количеством дипломников у каждого.

требуемый результат:

| spdp  |  cd |
|-------|-----|
|  1    |  2  |
|  2    |  1  |

запрос:

```SQL
SELECT spdp, COUNT(*) as cd
FROM СТУДЕНТ
WHERE spdp IS NOT NULL
GROUP BY spdp
```

пример: получить средние балы студентов
запрос:

```SQL
SELECT osnum, AVG(ocen) as avgo
FROM ОЦЕНКА
GROUP BY osnum
```
результат:

| osnum  | avgo |
|--------|------|
|  1     |  10  |
|  2     |  8   |
|  3     |  4   |

пример: средние баллы у студентов группы Г-2
запрос:

```SQL
SELECT sname, AVG(ocen) as avgo
FROM ОЦЕНКА, СТУДЕНТ
WHERE snum = osnum AND sgrp = 'Г-2' 
GROUP BY sname, snum
```

> **Замечание:** <br>
> В списке полей SELECT могут присутствовать толя поля группировки и группировочные функции.

из замечания следует, что так написать нельзя (т.к. sname -- не поле группировки и не функция):

```SQL
SELECT sname, AVG(ocen) as avgo
FROM ОЦЕНКА, СТУДЕНТ
WHERE snum = osnum AND sgrp = 'Г-2' 
GROUP BY snum
```
зато запрос может быть таким:

```SQL
SELECT nin(sname) as sname, AVG(ocen) as avgo
FROM ОЦЕНКА, СТУДЕНТ
WHERE snum = osnum AND sgrp = 'Г-2' 
GROUP BY snum
```

пример: количество дипломников у всех преподавателей(не только у дипломных руководителей).
запрос:

```SQL
SELECT pname, COUNT(snum) as cd
FROM ПРЕПОДАВАТЕЛЬ LEFT JOIN СТУДЕНТ ON spdp = pnum
GROUP BY pname, pnum
```

результат:

| pname  | cd  |
|--------|-----|
|  П-1   |  2  |
|  П-2   |  1  |
|  П-3   |  0  |

##### HAVING

может быть необходимо наложить условие на записи, полученные после группировки.
такое условие указывается в предложении HAVING

пример: 
количество положительных оценок у дипломников каждой кафедры.
показывать только те кафедры, где дипломники получили больше одной положительной оценки,
а в названии кафедры есть буква 'К':

```SQL
SELECT pcaf, COUNT(*) as co
FROM ПРЕПОДАВАТЕЛЬ, СТУДЕНТ, ОЦЕНКА
WHERE pnum = spdp AND snum = osnum AND ocen >= 4 AND pcaf LIKE '*К*'
GROUP BY pcaf
HAVING COUNT(*) > 1
```

##  Подзапросы
пример: получить дипломников преподавателя П-1

```SQL
SELECT sname from СТУДЕНТ
WHERE spdp = (SELECT pnum FROM ПРЕПОДАВАТЕЛЬ WHERE pname = 'П-1')
```

пример: вернуть дипломников кафедры К-1

```SQL
SELECT sname from СТУДЕНТ
WHERE spdp IN (SELECT pnum FROM ПРЕПОДАВАТЕЛЬ WHERE pcaf = 'К-1')
```

пример: руководители дипломников, имеющих неудовлетвориельные оценки
```SQL
SELECT pname 
FROM ПРЕПОДАВАТЕЛИ
WHERE pnum IN (SELECT spdp FROM СТУДЕНТ WHERE snum IN (SELECT osnum FROM ОЦЕНКА WHERE ocen < 4))
```

пример: список студентов, которые не сдавали экзамены преподавателю П-3
```SQL
SELECT sname 
FROM СТУДЕНТ
WHERE snum NOT IN (SELECT osnum FROM ОЦЕНКА WHERE opnum = (SELECT pnum FROM ПРЕПОДАВАТЕЛЬ WHERE pname = 'П-3'))
```

пример: студенты, у которых средний балл меньше, чем средний балл студента С-1:
```SQL
SELECT sname, AVG(ocen) as avgo
FROM СТУДЕНТ, ОЦЕНКА
WHERE snum = osnum
GROUP BY sname, snum
HAVING AVG(ocen) < (SELECT AVG(ocen) FROM ОЦЕНКА WHERE osnum = (SELECT snum FROM СТУДЕНТ WHERE sname = 'C-1'))
```

## Операторы ANY / SOME и ALL

##### ANY
параметрами операторов являются подзапросы:
`поле операция_сравнения ANY (Подзапрос)`
результат -- ИСТИНА, если операция сравнения истина хотя бы для одного возвращаемого значения подзапроса.

если подзапрос не возвращает значений -- результат ANY ложный.

##### ALL
`поле операция_сравнения ALL (Подзапрос)`
результат -- ИСТИНА, если операция сравнения истина для всех возвращаемых значения подзапроса.

пример: преподаватели не имеющие дипломников:
```SQL
SELECT pname 
FROM ПРЕПОДАВАТЕЛЬ
WHERE pnum <> ALL (SELECT spdp FROM СТУДЕНТ)
```

> **Замечание:** <br>
> `IN` эквивалентно `= ANY` <br>
> `NOT IN` эквивалентно `<> ALL`


## Связанный подзапрос
связанным подзапросом наывается подзапрос который использует значения из основного запроса

Студенты сдававшие экзамен 11 января : 
```SQL
 SELECT sname from СТУДЕНТ WHERE snum IN (SELEC osnum from ОЦЕНКА WHERE odate = '11/01')
 
 SELECT sname from СТУДЕНТ WHERE '11/01' IN (SELECT odate FROM ОЦЕНКА WHERE osnum = snum)
```
> как работает 2 выриант : выполняется цикл по записям основного запроса, для каждой такой записи выполняется подзапрос, результат оценивается и на основании этого запись основного запроса включается или нет в результат

Получить фамилии студентов у которых средний балл ниже чем общий средний балл в их группе: 
```SQL
 SELECT sname from СТУДЕНТ as C , ОЦЕНКА 
 WHERE osnum = snum 
 GROUP BY  sname, snum , sgrp
 Having avg(ocen) < (SELECT avg(ocen) FROM ОЦЕНКА  where osnum IN(SELECT snum from СТУДЕНТ where sgrp = C.sgrp))
```
## Оператор EXISTS(существует) 
формат : exists(подзвапрос) возвращается истина если результат подзапроса не пуст

студенты сдававшие экзамен 11 января :
```SQL
 SELECT sname from СТУДЕНТ where EXISTS(SELECT * FROM ОЦЕНКА where odate = '11/01' and and snum = osnum)
```
преподаватели у которых все дипломники не имеют удовлетворительных оценок : 
```SQL
 SELECT pname  FROM ПРЕПОДАВАТЕЛЬ WHERE NOT exists(SELECT * FROM СТУДЕНТ WHERE spdp =  pnum and exists(SELECT * FROM ОЦЕНКА where snum = osnum and ocen < 4))
```
преподаватели у которых ровно 1 дипломник ^ 
```SQL
 SELECT pname FROM ПРЕП where exists(select * from СТУДЕНТ c spdp = pnum and not exists(select * from CТУДЕНТ where spdp = pnum and snum <> c.snum ))
```
## Объединение результатов запроса 
формат : 
```
запрос 1
union [all]
запрос 2
```
получить коды и фамилии руководителей дипломов и дипломников :
```SQL
 SELECT pnum as "код" , pname as 'фио' , "п" as "тип" FROM преп where pnum in (select spdp from студ)
 UNION
 SELECT snum , sname , 'c' FROM СТУДЕНТ where spdp is not null
```
union удаляет повторы, что бы не удалять пишется `UNION ALL`

union позволяет избавиться от LEFT JOIN
пример: получить фамилии всех студентов. для дипломников указать руководителей

с LEFT JOIN
```SQL
  SELECT sname, pname
  FROM СТУДЕНТ LEFT JOIN ПРЕПОДАВАТЕЛЬ ON spdp = pnum
```

c UNION
```SQL
  SELECT sname, pname
  FROM СТУДЕНТ INNER JOIN ПРЕПОДАВАТЕЛЬ ON spdp = pnum
  UNION ALL
  SELECT sname, NULL
  FROM СТУДЕНТ
  WHERE spdp IS NULL
```

> ORDER BY указывается после всех объединяемых запросов

задача: получить сведения об успеаемости в том числе оценки студентов, их средние баллы, 
средние баллы по группам и общий средний балл.

```SQL
  SELECT sgrp, sname, odate, ocen, 0 AS s1, 0 AS s2, 0 AS s3
  FROM СТУДЕНТ, ОЦЕНКА
  WHERE snum = osnum
  
  UNION ALL
  
  SELECT sgrp, sname, NULL, AVG(ocen), 0, 0, 1
  FROM СТУДЕНТ, ОЦЕНКА
  WHERE snum = osnum
  GROUP BY snum, sname, sgrp
  
  UNION ALL
  
  SELECT sgrp, NULL, NULL, AVG(ocen), 0, 1, 0
  FROM СТУДЕНТ, ОЦЕНКА
  WHERE snum = osnum
  GROUP BY sgrp
  
  UNION ALL
  
  SELECT 'Итого', NULL, NULL, AVG(ocen), 1, 0, 0
  FROM ОЦЕНКА
  
  ORDER BY s1, sgrp, s2, sname, s3, odate
```

## Операторы модификации данных

* INSERT
* UPDATE
* DELETE

#### INSERT
Добавление записей.

INSERT INTO Таблица (Список полей) VALUES (Список значений) 

пример: 
```SQL
  INSERT INTO СТУДЕНТ VALUES (5, 'C-5', 'Г-1', 3)
  INSERT INTO СТУДЕНТ (sgrp, sname) VALUES ('Г-1', 'C-6')
```

Добавление из подзапроса:
INSERT INTO Таблица (Список полей) SELECT-ПОДЗАПРОС

Студентов дипломников. имеющих средний бал выше девяти сделать преподавателями на тех кафедрах
где работают их руководители


```SQL
  INSERT INTO ПРЕПОДАВАТЕЛЬ (pname, pcaf) SELECT sname, pcaf 
                                          FROM СТУДЕНТ, ПРЕПОДАВАТЕЛЬ 
                                          WHERE spdp = pnum AND 
                                                snum IN (
                                                  SELECT osnum
                                                  FROM ОЦЕНКА
                                                  GROUP BY osnum
                                                  HAVING AVG(ocen) > 9
                                                )
```

#### UPDATE
Изменение записей.

```SQL
UPDATE Таблица SET поле1 = значение1 [, поле2 = значение2] [WHERE условие]
```

Оценки преподавателя П-3 увеличить на один балл

```SQL
UPDATE ОЦЕНКА SET ocen = ocen + 1 WHERE opnum = (SELECT pnum FROM ПРЕПОДАВАТЕЛЬ WHERE pname = 'П-3') AND ocen < 10
```

Всех дипломников преподавателя П-1 передать преподавателю с кодом 3.

```SQL
UPDATE СТУДЕНТ SET spdp = 3 WHERE spdp = (SELECT pnum FROM ПРЕПОДАВАТЕЛЬ WHERE pname = 'П-1')
```

#### DELETE
Удаление строки таблицы.

```SQL
DELETE FROM Таблица 
[WHERE Условие]
```

Пример:
удалить оценки студента С-3

```SQL
DELETE FROM Оценка
WHERE snum = (SELECT snum from Студент WHERE sname = 'C-3')
```

#### TRUNCATE
Оператор очистки таблицы. (Не поддерживается в Access)

```SQL
TRANCATE TABLE Таблица
```

# Microsoft SQL Server

Имя сервера: VAK-DB\SQLExpress
Имя базы: StudTraining

#### Из Access в MS SQL Server
`
Вкладка Таблицы -> Export -> (Тип данных: ODBC-источник) -> mdb -> 
Создать -> Выбрать сервер -> VAK-DB\SQLExpress -> StudTraining
`

## Расширения языка SQL в MS SQL Server

#### Расширения в операторе Select

```SQL
SELECT TOP число[PRCNT] [WITH TIES]
```

Пример:
получить средние баллы студентов

```SQL
SELECT TOP 1 osnum, AVG(ocen) as AVGO
FROM Оценка
GROUP BY osnum
ORDER BY AVG(ocen), osnum DESC
```

`WITH TIES`
в результат входят дополниельные записи,
которые в соответствии с условиями сортировки совпадают с последней отобранной записью.


#### Создание таблиц с помощью SELECT
```SQL
SELECT поля INTO таблица [FROM] ...
```

Результат запроса помещаются в таблицу.

```SQL
SELECT osnum, AVG(ocen) as avgo INTO СредБал
FROM Оценка
GROUP By osnum
```

#### Использование подзапросов в списке полей
Подзапрос обычно является связанным и должен возвращать не больше одного значения.

Получить фамилии студентов и их сдрений балл.
```SQL
SELECT sname, (SELECT AVG(ocen) FROM оценка WHERE osnum = snum) as avgo
FROM Студент
```

#### Использование подзапросов как источников данных в предложении FROM

Фамилии и средние баллы студентов

```SQL
SELECT sname, avgo 
FROM Сдудент, (SELECT osnum, AVG(ocen) as avgo FROM Оценка GROUP BY osnum)
WHERE snum = osnumr
```

#### Дополнительные вилы JOIN

* INNER / LEFT / RIGHT
* FULL
* CROSS
* NATURAL


#### Расширения в операторе UPDATE

```SQL
UPDATE SET [поля]
[FROM таблица]
[WHERE условие]
```

Нужно получить таблицу следующей структуры:

| СведенияОСтудентах |
----------------------
|      snum          |
|      sname         |
|      sgrp          |
|      spdp          |
|      avgo          |
|      pname         |
|      pcaf          |


Пишем следующие запросы:

```SQL
INSERT INTO СВОС(snum, sname, sgrp, spdp)
SELECT * FROM Студент
```

```SQL
UPDATE СВОС avgo = (SELECT AVG(ocen) FROM Оценка WHERE osnum = snum)
```

```SQL
UPDATE СВОС SET
pname = (SELEC pname FROM ПРЕП WHERE pnum = spdp)
pcaf = (SELEC pname FROM ПРЕП WHERE pnum = spdp)
```

Или так (С помощью UPDATE FROM в MS SQL):

```SQL
UPDATE СВОС SET pname = П.pname, pcaf = П.pcaf
FROM ПРЕП AS П WHERE spdp = pnum
```

Или так, чтобы информация с NULL коректно обновлялась (UPDATE FROM в MS SQL)

```SQL
UPDATE СВОС SET pname = П.pname, pcaf = П.pcaf
FROM СВОС LFET JOIN ПРЕП ON spdp = pnum AS П
```

#### Расширения в операторе DELETE
```SQL
DELETE [FROM] Таблица
[FROM список_таблиц]
[WHERE условие]
```

Пример(NON MS-SQL):
```SQL
DELETE FROM Оценка WHERE osnum = (SELECT snum FROM Студент WHERE sname='C-3')
```

(MS-SQL)
```SQL
DELETE FROM Оценка
FROM Студент
WHERE osnum = snum AND sname = 'C-3'
```

# Создание таблиц в MS-SQL сервер

#### Оператор создания таблиц
```SQL
CREATE TABLE имя_таблицы
(определение поля | определения вычисляемого поля | ограничения на таблицу) [, ...]
[ON группа_файлов]
[TEXTIMAGE_ON группа_файлов]
```

##### Определение поля
`
                              Значение по умолчанию для поля   Поле счётчик(от начала с шагом i)       Поле с уникальным значением
                                                  \/                     \/                              \/
имя тип[(длина)] [collate алф. сортировки] [DEFAULT выражение] [ [IDENTITY [(начало, инкремент)]] | [ROWGUIDCOL] ] [ограничения на столбец [,...]]
`

###### Ограничения на столбец
```SQL
NULL        | NOT NULL  
PRIMARY KEY | UNIQUE  

[FOREIGN KEY] REFERENCES родительская_таблица [(поле)]        \
[ON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }]   > -- определение внешнего ключа
[ON UPDATE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }]  /
```

`ON DELETE` определяет действие в данной таблице при удалении записи в данной таблице.
* `NO ACTION` - запретить удаление
* `CASCADE` - удалить данную запись вслед за записью
* `SET NULL` - занести NULL в данную таблицу на место удалённой в другой таблице
* `SET DEFAULT` - занести значение по умолчанию

`CHECK(условие)` - условие, проверяющее значение поля.  // `CHECK(поле <= 10)` 

###### Пример

```SQL
CREATE TABLE Преподаватель
(
  pnum  int PRIMARY KEY IDENTITY, 
  pname varchar(40) NOT NULL,
  pcaf  varchar(100)
)

GO

CREATE TABLE Студент
(
  snum  int PRIMARY KEY IDENTITY,
  sname varchar(40) NOT NULL,
  sgrp  varchar(10),
  spdp  int REFERENCES Преподаватель (pnum)
           ON DELETE SET NULL
)

GO

CREATE TABLE Оценка
(
  onum  int PRIMARY KEY IDENTITY,
  opnum int NOT NULL REFERENCES Преподаватель (pnum)
  osnum int NOT NULL REFERENCES Студент (snum)
                     ON DELETE CASCADE
  odate datetime NOT NULL,
  ocen  int CHECK(ocen >= 1 AND ocen <= 10)
)

GO
```

##### Оператор уничтожения таблиц
```SQL
DROP TABLE имя_таблицы
```

Для нормального функционирования скрипта создания базы нужно дописать в начале DROP TABLE
(Нельзя удалять родительские таблицы, поэтому удалять нужно в обратном порядке)

```SQL
DROP TABLE Оценка
GO
DROP TABLE Студент
GO
DROP TABLE Преподаватель
GO
```

##### Описание вычисляемого столбца
```SQL
описание_вычисляемого_столбца AS выражение
```

Пример:
```SQL
CREATE TABLE Tovar
( ...
  price money,
  _count int,
  cost AS price * _count
)
```

###### Ограничение на таблицу

```SQL
[constraint имя_ограничения] 
  PRIMARY KEY (столбец [, столбец])
  UNIQUE (столбец [, стобец])
  FOREIGN KEY (столбец [, стобец]) REFERENCES родительская_таблица [ON DELETE...] [ON UPDATE...]
  CHECK (условие)
```

#### Модификация структуры таблицы

```SQL
ALTER TABLE имя_таблицы
  ALTER COLUMN имя_стобца параметры
  ADD COLUMN столбец [, ...]
  ADD ограничение_на_таблицу
  DROP COLUMN столбец [, ...]
  DROP ограничение_на_таблицу
```

(Название связи -- FK_Дочерняя_Родительская)

Удаление таблиц с удалением связей:
```SQL
  ALTER TABLE Студент DROP FK_Студ_Преп
  GO
  ALTER TABLE Оценка  DROP FK_Оценка_Преп, 
                           FK_Оценка_Студ
  
  GO
  
  DROP TABLE Преподаватель
  GO
  DROP TABLE Студент
  GO
  DROP TABLE Оценка
  GO
  
  -- Создание таблиц
  CREATE TABLE Преподаватель
  (
  pnum  int PRIMARY KEY IDENTITY, 
  pname varchar(40) NOT NULL,
  pcaf  varchar(100)
  )

  GO

  CREATE TABLE Студент
  (
    snum  int PRIMARY KEY IDENTITY,
    sname varchar(40) NOT NULL,
    sgrp  varchar(10),
    spdp  int 
  )

  GO

  CREATE TABLE Оценка
  (
    onum  int PRIMARY KEY IDENTITY,
    opnum int NOT NULL
    osnum int NOT NULL
    odate datetime NOT NULL,
    ocen  int CHECK(ocen >= 1 AND ocen <= 10)
  )

  GO

  ALTER TABLE Студент ADD CONSTRAINT FK_Студ_Преп FOREIGN KEY (spdp) REFERENCES Преподаватель
  GO
  ALTER TABLE Оценка CONSTRAINT FK_Оценка_Преподаватель FOREIGN KEY (opnum) REFERENCES Преподаватель,
                     CONSTRAINT FK_Оценка_Студент FOREIGN KEY (osnum) REFERENCES Студент
```

#### Создание и использользование представлений

Представление (VIEW) это запрос выборки данных, сохранённый в базе данных под некоторым именем
имена представлений можно использовать в других запросах на ряду с именами таблиц

```SQL
CREATE VIEW Имя_Представления [(список полей)] AS
SELECT-Запрос
```

Пример:
```SQL
CREATE VIEW Кафедра1 AS
SELECT pnum, pname, pcaf
FROM ПРЕПОДАВАТЕЛЬ where pсфа = 'П-1'
```

Уничтожение представления:
```SQL
DROP VIEW имя_представления
```

Для чего были созданы представления:
1. Упростить написание запросов
2. Разграничение прав доступа

Если имя представления можно использовать в операторах модификации данных (INSERT, UPDATE, DELETE)
такое представление называется обновялемым, иначе только читаемым.

Представление обновляемо если:
1. Оно основано на одной таблице
2. Содержит первичный ключ  таблице
3. Не содержит полей с атрибутом Not NULL если для них не указано значение по умолчанию
4. Не содержит операции DISTINCT
5. Не содержит группировки

Для MS SQL представление может содержать перемножение таблиц, но в операторах обновления должны использоваться поля только одной таблицы.

Можно ограничить действие операторов insert и update так, чтобы можно было добавить или изменить записи только при условии, что они будут
видны через представление:

```SQL
CREATE VIEW имя AS
SELECT ...
WITH CHECK OPTION
```

[comment]: # (LABS END)

# Назначение индексов
Индексы -- объекты, связанные с одной из таблиц БД и указывающие последовательность записей при 
использовании сортировки по одному или нескольким полям таблицы.

Индексы используются сервером в операторе выборки данных и автоматически модифицируются при изменении данных.

Индексы позволяют ускорить:
* поиск данных
* выборку данных в отсортированной последовательности
* соединение таблиц
* группировку

Индексы автоматически создаются для первичных ключей и поля UNIQUE.

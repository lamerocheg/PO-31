# Базы данных

-----

## Назначение СУБД(Систем управления базами данных)

Основная идея это хранение на внешнем носителе не только самих данных , но и описание их структур.

![alt text](http://i.imgur.com/lnG78pB.png "классическое взаимодействие с файлами")

![alt text](http://i.imgur.com/TkRCf0J.png "взаимодействие программ с файлами при помощи субд")

#### достоинства использования СУБД :

1. снижение сетевого трафика.
2. возможность создания программ независимых от структуры хранения данных на внешнем устройстве.
3. возможность использования стандартных качественно реализованных СУБД алгоритмов обработки данных(сортировка, поиск, ведение индексов и т. д.)
4. автоматическое поддержание целостности данных. Авто резервное копирование, откат транзакций и др.
5. разграничение доступа к данным за счет авторизации пользователя и установки уровня по умолчанию
6. автоматизация отображения данных

---

## Иерархическая и сетевая модель данных

СУБД различаются способом представления связей между объектами(моделями данных) 

1. иерархическая
2. сетевая
3. реляционная
4. пост-реляционная
 
Исторически первой была система IMS  производства IBM  ее украли и назвали OKA. В ней 1 объект является главным а остальные подчиненные на разных уровнях иерархии.
недостаток : реальные объекты не всегда находятся в строгой иерархической зависимости. 
В сетевых базах любой объект может быть как главным так и подчиненным ADABAS ее украли и назвали ADABAC. Основной недостаток -  это инструмент для программистов.
В начале 70-х Кодд предложил реляционную модель СУБД.

-

## Реляционная модель СУБД.

Кодд стремился упростить структуру базы.
В традиционных реляционных СУБД данные хранятся в таблицах. Таблица соответствует типу объекта. Строка таблицы это экземпляр объекта. Столбец — значения атрибута в экземплярах. Имена таблиц уникальны в базе. Имена столбцов уникальны в таблице. Таблица может иметь произвольное количество строк. Возможно — ни одной. Строки таблицы не упорядочены. Нет понятия 1 строка или последняя. Каждая таблица содержит поле или совокупность полей однозначно определяющих запись это поле или совокупность называется первичный ключ. Поле или совокупность полей значение которых совпадают со значением первичного ключа одной из записей в другой таблице называются внешним ключом совокупность внешнего и первичного ключа определяют связь между объектами таблица с первичным ключом родительская , таблица с внешним ключом дочерняя. 

-

## Проектирование баз данных

#### этапы :

1. определение состава объектов
2. определение связи между объектами 
3. определение атибутов объектов 
4. нормализация отношений 

Предположим что база данных об учебном процессе. объекты будут `факультет` , `кафедра` , `преподаватель` , `группа` , `студент`

есть три типа связи. 
1. 1 к 1 :одному экземпляру первого типа соответствует 1 экземпляр второго типа (<--->). хотя такое возможно но встречается редко и вообще быть не должно. есть 2 причины почему одну таблицу можно разделить : производительность и упрощение администрирования. 
2. 1 к многим : 1 экземпляру объекта первого типа соответствует много экземплярова объектов второго типа (<--->->) .
3. многие ко многим : одному обекту первого тип могут соответствовать многие и наоборот. такх связей не существует . если реально такая связ есть то проблема решается добавленем еще одного типа объекта. дочернего по отношению к ним.

####Определение состава атрибутов объекта

1. поля первичного ключа
2. поля внешних ключей в дочерних таблицах
3. не ключевые атрибуты

####Нормализация отношений 

нормализация отношений это процесс выбора оптимального состава объектов. 

Пусть сведения о нагрузке представлены в таблице нагрузка преподавателя

####1НФ

Говорят что отношения находятся в первой нормальной форме если значения каждого атрибута неделимо.

Недостатки :
1. проблема реализации обновления данных(нельзя добавить преподавателя не имеющего нагрузки)
2. при удалении нагрузки теряются сведения о преподавателе
3. изменения значения атрибутов требуют просмотра всей таблицы 

####2НФ

отношения в первой нормальной форме и каждый неключевой атрибут полностью зависит от всех атрибутов первичного ключа

переход к 2НФ разделением отношения на несколько

есть недостатки :

1. нельзя добавить кафедру не указав преподавателя
2. при удалении преподавателей теряются ведения о кафедрах
3. изменение зависимости кафедра-факультет требует просмотра всего отношения 

####3НФ

Говорят что отношения в третьей нормалной форме если она во второй и каждый неключевой атрибут нетранзитивно зависит от ключа

преобразование путем разделения отношений 

достоинством нормализации является устранение избыточности данных. 

### дополниельные рекомедации по проектированию :

1. не нужно включать в базу атрибут значение которого может быть расчитано по другим атрибутам. т.к. тогда значние нового атрибута придется пересчитывать при изменении исходных данных. <триггер>
2. при наличии повторяющегося значения атрибута в таблице обычно выгодно создать дополнительную таблиу-справочник в формате код-значение. значение атрибут может мняться во времени и код решает проблему. при наличии справочника в приожениях можно выполнять не ввод значения а выбор из списка.

-

## Создание базы данных

теперь надо создать реальную базу данных. описать атблицы поля и связи. изначально в MS Acces. В любой СУБД есть визуальные средства для определения визуальной структуры базы данных. когда созаем пустую базу данных. потом можем создавать таблицы появляется форма где можно вводить имена полей и указывать их типы. 
#### Типы данных(полей)
######MS Access
* текстовое поле(250 символов/ можно указать длину)
* Memo(текстовое поле но длина до 2гб)
* числовой(в свойствах тип числа . целый - 2 байта , длинный целый 4 байта , плавающие 5 и 8 байт)
* денежный тип
* счетчик(длинное целое, значение которого автоматчески вырабатывается для каждой новой записи)
* логический
* дата\время
* #m/d/y# константа даты

######MS SQL Server
* char, varchar(эквиваленты ткстового поля до 8192 символов)
* text(устаревает) , varchar(max) 
* nchar , nvarchar , ntext - кодировка юникод
* tinyint целое 1 байт
* smallint 2 байта
* int 4 байта
* bigint 8 байтовое целое 
* money
* int + identity
* bit
* datetime

для поля счетчика должно быть индексировано и совпадения недопускаютяы
#### создание схемы данных

схемы данных испольуются при визуальном создании запросов . с помощью схемы данных указываются правила поддержания ссылочной целосности
меню - съема данных. 
правая кнопка на связи -> ссылочная целосность. в дочерню таблицу нельзя добавить запись с неверным кодом объекта раддомтельвой и нельзя удалить объект родительской если к нему привязаны объекты дочерней

##правило Кодда 

* правило информации : вся информация в базе данных представлена в виде таблиц
* правило гарантированного доступа : доступ к любому значению обеспечивается путем использования комбинации имени таблицы , значения первичного ключа и имени столбца 
* правило поддержки недействительных значений : должны поддерживаться `NULL` значения которые отличаются от пустой строки, строки пробелов, нуля и означают отстутствие значения 
* правило каталога основанного на реляционной модели : описание структуры базы данных тоже хранится в таблице 
* правило исчерпывающего подъязыка дат : должен существовать язык общения с СУБД операторы которого представимы в виде строки символов в соответсви с не которым синтаксисом. язык обеспечивает пределение структуры данных определение представлений которые являются виртуальными таблицами и позволяют показывать различным пользвателям различные фрагменты баз данных. поддерживать обработку данных. определение условий целосности данных. идентификацию прав доступа. границы транзакций.
* правило обновления представлений : все представления которые теоретически можно обновить должны быть дступны для обовления
* правило добавления обновления и удаления : возможность работы с таблицей как с единым целым должно быть не только при просмотре , но и при добавлении обновлении и удалении записи
* правило независимости физических данных : программы должны остаться нетронутыми при любых изменеиях физических способов хранения данных и методов работы с ними 
* правило независимости логических данных : прикладные программы должны отставаться нетронутыми при внесении в таблицы любых именения которые позваляют сохранить нетронутыми ранее содержащиеся в таблицах данные
* правило независимости условий целосности : дожна уществовать воможность определить условие целоности пеифические для конкретной базы даных а не хранть их в базе данных а не в прикладной программе 
* правило независимости распространения : реляционная СУБД не должна завсеть от птребностей конкртного клиента 
* првио единственности : если в реляционой системе есь низкоуровневый язык то не должно быть возмоостей оботи с помощиью этого языка учловия целосности данных

## операции реляционой алгебры 
операции реляционной алгебры это операции над таблицами результатом которых тоже являются таблицы . есть 5 основных и 4 вспомогательных. 
основные : 
* объединение 
* разность 
* проекция 
* выбор 
* декартово произведение . 
вспомогательные :
* пересечение 
* соединение 
* слияние
* деление
 вспомогательные выражаются через основные и служат для краткости записи.

# таблицы

#### объединение

`T = R U S` записи которые вхдят хотябы в одну из таблиц 

`ST = SM U STP` местные и те кто со стипендией 

#### разность

`T = R - S` записи которые входят в R но не входят в S

#### проекция

`T = R | Y``  несовпадающие строки из столбцов Y

`GR = (SM U SI) | {ГРП}` список групп

`GS = STP | {ГРП}` список групп где хотя бы один имеет стипендию

`GR - GS` группы где никто не получает стипендию 
 
 `STP|{ГРП} - (((SM U SI) - STP)|{ГРП}` групы в которых хотя-бы один не получает стипендию
 
#### операция выбора
 
 `T = R : L` подмножество строк R удовлетворяющее L
 
 `ДВ = (ОС ж ОЦН < 4) | {КСТО}` коды двоечников
 
#### декартово произведение
 
 `T = R * S` пусть  R и S  содержат k1 k2 столбцов и n1 n2 строк. декартово произведение это таблица из k1 + k2 столбцов включающее в себя все сочетация строк из R и S (n1 * n2) 
 
 `(SM U SI) * ДВ` 
 
 `таблица`
 
 `(((SM u SI) * ДВ) : КСТ = КСТО) | {ФИО , ГРП}`
 
###### дополнительные операции выражаюются из базовых
 
 
## Выборка из одной таблицы

примеры на трех таблицах : преподаватель студент и оценка


# таблицы 


##### преподаватель
* Pnum
* Pname
* Pcat


##### студент 
* Snum 
* Sname
* Sgrp
* Spdp(рук дипл раб)

##### оценка 
* Onum
* OPnum
* OSnum 
* Odate
* Ocen

#### общий формат
```SQL
SELECT список_полей
 FROM список_таблиц
 [WHERE условие]
 [GROUP BY поле_группировки]
 [HAVING условие]
 [ORDER BY поле_сортировки]
```

в качестве списка полей можно указать `*` т.е. все поля 

```SQL
 SELECT * FROM  ПРЕПОД
```
можно перечислять поля через запятую

```SQL
 SELECT Sgrp , Sname FROM  СТУДЕНТ
```
если перед списком полей указать `DESTINCT` то удаляются повторяющиеся записи

```SQL
 SELECT DISTINCT Sgrp FROM  СТУДЕНТ
```
для поля можно задать новое имя `[as] новое_имя` 

```SQL
 SELECT Pname as ФИО , Pcaf as Кафедра FROM  ПРЕП
```
вместо имени поля можно указать выражение

```SQL
 SELECT OSnum , Odate , ocen , 10 - ocen as Недобор FROM ОЦЕНКА
```
#### WHERE 
в предложении WHERE задается условие отбора записей
* операторы` < > <= >= = <> !=`
* логические операторы `AND , OR , NOT`
* специальные операторы 

преподаватели кафедры К-1 :
```SQL
 SELECT Pname from ПРЕПОД where pcaf = `K-1`
```
студенты групп Г-1  и Г-2:
```SQL
 SELECT * from  СТУДЕНТ Sgrp = `Г-1` OR Sgrp = `Г-2`
```

положительные оценки студентов полученные с 15 по 20 января:
```SQL
 SELECT * from  ОЦЕНКА where ocen >= 4 and Odate >= `15/01` and Odate <= `20/01`
```
поожительные оценки студентов с кодами 1 и 2
```SQL
 SELECT * from  ОЦЕНКА where ocen >= 4  and ( osnum = 1 or osnum = 2)
```
#### специальные операторы 
`IN , BETWEEN , LIKE , IS NULL`

* IN `поле IN (знач1 , знач 2)`

преподаватели кафедры К-1 И К-2
```SQL
 SELECT Pname , Pcaf FROM  ПРЕП  where pcaf IN(`K-1` , `K-2`)
```
все студенты кроме студентов из групп Г-1 Г-2: 

```SQL
 SELECT * FROM  СТУДЕНТ where not sgrp in (`Г-1` , `Г-2`)
```

* Between `поле Between знач1 and знач2` находится в диапазоне включая границы 

получить оценки от 6 до 8 полученные с 10 до 15
```SQL
 SELECT  * from ОЕНКА where ocen between 6 and 8 and odate between '10/01' and '15/01' 
```

* Like `поле LIKE шаблон`

 используется только в символьных полях

* IS NULL  

при сравнении значений null с не null  не true / false , а  unknown == false

студенты без руководителя дипломной:
```SQL
 SELECT * from СТУДЕНТ spdp is null
```

студенты с руководителем дипломной:
```SQL
 SELECT * from СТУДЕНТ spdp is not null
```
##объеденение нескольких таблиц

получить фамилии дипломников с указанием фамилии руководителя
```SQL
 SELECT * FROM СТУДЕНТ , ПРЕП
```

получить оценки студентов из гуппы г-2 с указанием фамилии преподавателя и даты
```SQL
 SELECT pname , sname , odate , ocen 
 FROM  ПРЕП , СТУД , ОЦЕНКА 
 WHERE osnum = snum and opnum = pnum and sgrp = 'г-2'
```
фамилии руководителей дипломой в группах г-1 и г-2
```SQL
 select distinct pname
 from ПРЕП, СТУД
 where spdp = pnum and (sgrp = 'г-1' or sgrp = 'г-2')
```
если будут поля назван одинаково то имя полей нужно уточнять ИМЯ_ТАБЛИЦЫ.название поля

для таблицы можно дать новое имя. `from таблица [as] новое_имя`

получить все пары фамилий студентов обучающихся в одной и той же группе
```SQL
select с1.sname as ФИО1,  с2.sname as ФИО2 from студент с1 , студент с2 where с1.sgrp = с2.sgrp and с1.snum <> с2.snum
```
для объеденения таблиц можно использовать оператор `join` в предложении `from` 
```SQL
табл1 {INNER | LEFT | RIGHT} JOIN табл2 ON условие
```
фамилии дипломников с указаие руководителя
```SQL
 SELECT sname , pname
 from СТУДЕНТ INNNER JOIN преп on spdp=pnum

```
